

* numhask-array

[[https://hackage.haskell.org/package/numhask-array][file:https://img.shields.io/hackage/v/numhask-array.svg]] [[https://github.com/tonyday567/numhask-array/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/numhask-array/workflows/haskell-ci/badge.svg]]

* Usage

This package provides an interface into the numhask API, and both type and value level shape manipulation routines.

#+begin_src haskell
:set -XRebindableSyntax
import NumHask.Prelude
import NumHask.Array
#+end_src

In situations where shape is only known at run-time, a clear module configuration is:

#+begin_src haskell
import NumHask.Array.Shape
import qualified NumHask.Array.Fixed as F
import qualified NumHask.Array.Dynamic as D
#+end_src

* recip development

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

#+begin_src haskell-ng :results output :exports both
>>>>>>> 50f9423 (shapeList and :|)
:r
:set -Wno-type-defaults
:set -Wno-unused-do-bind
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XOverloadedLabels
:set -XRebindableSyntax
:set -XDataKinds
import Data.Functor.Rep
import NumHask.Prelude
import NumHask.Array.Fixed qualified as F
import NumHask.Array.Shape qualified as S
import NumHask.Array.Dynamic qualified as D
putStrLn "ok"
#+end_src

** Cholesky decomposition

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

Example from https://rosettacode.org/wiki/Cholesky_decomposition#Haskell

#+begin_src haskell :results output :exports both
a = [25, 15, -5 ,15, 18, 0 ,-5,  0, 11] :: Matrix 3 3 Double
b = [ 18, 22, 54, 42 , 22, 70, 86, 62 , 54, 86, 174, 134 , 42, 62, 134, 106] :: Matrix 4 4 Double
chol a
chol b
fmap (fixed (Just 3)) (a `mmult` recip a)
fmap (fixed (Just 3)) (b `mmult` recip b)
fmap (fixed (Just 3)) (dot sum (*) b (recip b))
#+end_src

#+RESULTS:
#+begin_example
[[5.0, 0.0, 0.0],
 [3.0, 3.0, 0.0],
 [-1.0, 1.0, 3.0]]
[[4.242640687119285, 0.0, 0.0, -5.102196573270443e-15],
 [5.185449728701349, 6.565905201197403, 0.0, 0.0],
 [12.727922061357857, 3.0460384954008553, 1.6497422479090704, 0.0],
 [9.899494936611667, 1.624553864213788, 1.8497110052313648, 1.3926212476456026]]
[["1.000", "0.000", "-0.000"],
 ["0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
#+end_example

* dyno development

** imports

#+begin_src haskell-ng :results output
:r
:set -Wno-name-shadowing
:set -Wno-type-defaults
import NumHask.Prelude
import NumHask.Array.Dynamic as D
import NumHask.Array.Shape as S
import Prettyprinter
#+end_src

#+RESULTS:
: [1 of 5] Compiling NumHask.Array.Shape ( src/NumHask/Array/Shape.hs, interpreted ) [Source file changed]
: Ok, five modules loaded.

** 3-Dim example

#+begin_src haskell-ng :results output
let a = D.array [2,3,4] [0..23] :: D.Array Int
pretty a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

** scalars

#+begin_src haskell-ng :results output
s = D.tabulate [] (const 0) :: D.Array Int
s
pretty s
s1 = D.array [1] [0]
s1
pretty s1
s2 = D.toScalar 0
s2
pretty s2
#+end_src

*** tabulate

#+begin_src haskell-ng :results output
s3 = tabulate [] (const 3) :: D.Array Int
s3
s3' = tabulate [1] (const 3) :: D.Array Int
s3'
s3'' = tabulate (Scalar' 1) (const 3) :: D.Array Int
s3''
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [1], toVector = [3]}
: Array {toShape = [1], toVector = [3]}

*** indices

#+begin_src haskell-ng :results output
D.indices []
D.indices [3]
D.indices (Scalar' 3)
D.indices [2,3]
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [[]]}
: Array {toShape = [3], toVector = [[0],[1],[2]]}
: Array {toShape = [3], toVector = [Scalar' 0,Scalar' 1,Scalar' 2]}
: Array {toShape = [2,3], toVector = [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]]}

*** range

#+begin_src haskell-ng :results output
joins' $ fmap D.asArray $ D.indices []
joins' $ fmap D.asArray $ D.indices [3]
joins' $ fmap D.asArray $ D.indices (Scalar' 3)
joins' $ fmap D.asArray $ D.indices [2,3]
#+end_src

#+RESULTS:
: Array {toShape = [0], toVector = []}
: Array {toShape = [3,1], toVector = [0,1,2]}
: Array {toShape = [3], toVector = [0,1,2]}
: Array {toShape = [2,3,2], toVector = [0,0,0,1,0,2,1,0,1,1,1,2]}

*** diag

#+begin_src haskell-ng :results output
import NumHask.Array.Shape as S
:set -Wno-x-partial
a = D.array [] [3]
D.diag a
D.diag (D.array [3] [1,2,3])
D.diag (D.ident [3,2])
-- D.tabulate [S.minimum (zero:D.shape a)] (\xs -> index a (replicate (D.rank a) (head xs)))
-- D.tabulate [] (\xs -> index a (replicate (D.rank a) (head xs)))
-- S.minimum ((D.shape a) :: [Int])
-- index a []

#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [3], toVector = [1,2,3]}
: Array {toShape = [2], toVector = [1,1]}

** selects

#+begin_src haskell-ng :results output
D.selects [2] [1] (D.array [] [3::Int])
D.selects [0] [2] (D.array [3] [0..2::Int])
m = D.reshape [2,3] (D.range [6])
pretty m
D.selects [1] [0] (D.reshape [2,3] (D.range [6]))
D.selects [1] [2] (D.reshape [2,3] (D.range [6]))
D.selects [0,1] [1,2] (D.reshape [2,3] (D.range [6]))
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [], toVector = [2]}
: [[0,1,2],
:  [3,4,5]]
: Array {toShape = [2], toVector = [0,3]}
: Array {toShape = [2], toVector = [2,5]}
: Array {toShape = [], toVector = [5]}

#+begin_src haskell-ng :results output
:t D.index @[Int]
:t \a -> D.index @_ @[Int] a
:t D.index @_ @[Int]
#+end_src

#+RESULTS:
: D.index @[Int] :: FromVector [Int] Int => D.Array a -> [Int] -> a
: \a -> D.index @_ @[Int] a
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]
: D.index @_ @[Int]
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]

** folds



#+begin_src haskell-ng :results output
pretty $ D.folds [0,1] (sum . fmap (const one)) a
#+end_src

#+RESULTS:
#+begin_example
<interactive>:193:18: error: [GHC-83865]
    • Couldn't match expected type: D.Array Int -> b0
                  with actual type: [a1]
    • In the first argument of ‘D.folds’, namely ‘[0, 1]’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a

<interactive>:193:25: error: [GHC-83865]
    • Couldn't match type ‘(->) (f0 a0)’ with ‘[]’
      Expected: [Int]
        Actual: f0 a0 -> Int
    • Probable cause: ‘(.)’ is applied to too few arguments
      In the second argument of ‘D.folds’, namely
        ‘(sum . fmap (const one))’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a
#+end_example


** extracts

#+begin_src haskell-ng :results output
D.extracts [0,1] a
#+end_src

#+RESULTS:
: Array {toShape = [2,3], toVector = [Array {toShape = [4], toVector = [0,1,2,3]},Array {toShape = [4], toVector = [4,5,6,7]},Array {toShape = [4], toVector = [8,9,10,11]},Array {toShape = [4], toVector = [12,13,14,15]},Array {toShape = [4], toVector = [16,17,18,19]},Array {toShape = [4], toVector = [20,21,22,23]}]}

#+begin_src haskell-ng :results output
D.joins [0,1] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
D.joins [0,1] $ D.extracts [1,0] $ D.joins [1,0] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
pretty $ D.maps (D.reverses [0]) [0] a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

#+begin_src haskell-ng :results output
pretty $ D.insert 2 2 a (D.array [2,3] [100..105])
#+end_src

#+RESULTS:
: [[[0,1,100,2,3],
:   [4,5,101,6,7],
:   [8,9,102,10,11]],
:  [[12,13,103,14,15],
:   [16,17,104,18,19],
:   [20,21,105,22,23]]]

** dimension

#+begin_src haskell-ng :results output
S.dimension (D.shape a) 2
#+end_src

#+RESULTS:
: 4

** reverses

#+begin_src haskell-ng :results output
S.reverseIndex [0] [] []
S.reverseIndex [0] [5] [0]
S.reverseIndex [0] [5] [4]
S.reverseIndex [2] [2,3,4] [0,1,2]
#+end_src

#+RESULTS:
: []
: [4]
: [0]
: [0,1,1]

#+begin_src haskell-ng :results output
:t (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
#+end_src

#+RESULTS:
: (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
:   :: (Subtractive b, Foldable t, Eq a, Num b, Num a, Enum a) =>
:      t a -> [b] -> [b] -> [b]

#+begin_src haskell-ng :results output
pretty $ D.reverses [0] $ D.array [3,2] [1..6]
#+end_src

#+RESULTS:
: [[5,6],
:  [3,4],
:  [1,2]]

* fixed

#+begin_src haskell-ng :results output
:set -XPolyKinds
:t Array @[2,3]

#+end_src

#+RESULTS:
: Array @[2,3] :: Data.Vector.Vector a -> Array [2, 3] a

#+begin_src haskell-ng :results output
fromList [1..24] :: Array [2,3,4] Int
#+end_src

#+RESULTS:
: [[[1, 2, 3, 4],
:   [5, 6, 7, 8],
:   [9, 10, 11, 12]],
:  [[13, 14, 15, 16],
:   [17, 18, 19, 20],
:   [21, 22, 23, 24]]]
