

* numhask-array

[[https://hackage.haskell.org/package/numhask-array][file:https://img.shields.io/hackage/v/numhask-array.svg]] [[https://github.com/tonyday567/numhask-array/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/numhask-array/workflows/haskell-ci/badge.svg]]

* Usage

This package provides an interface into the numhask API, and both type and value level shape manipulation routines.

#+begin_src haskell
:set -XRebindableSyntax
import NumHask.Prelude
import NumHask.Array
#+end_src

In situations where shape is only known at run-time, a clear module configuration is:

#+begin_src haskell
import NumHask.Array.Shape
import qualified NumHask.Array.Fixed as F
import qualified NumHask.Array.Dynamic as D
#+end_src

* recip development

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

#+begin_src haskell-ng :results output :exports both
>>>>>>> 50f9423 (shapeList and :|)
:r
:set -Wno-type-defaults
:set -Wno-unused-do-bind
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XOverloadedLabels
:set -XRebindableSyntax
:set -XDataKinds
import Data.Functor.Rep
import NumHask.Prelude
import NumHask.Array.Fixed qualified as F
import NumHask.Array.Shape qualified as S
import NumHask.Array.Dynamic qualified as D
putStrLn "ok"
#+end_src

** Cholesky decomposition

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

Example from https://rosettacode.org/wiki/Cholesky_decomposition#Haskell

#+begin_src haskell :results output :exports both
a = [25, 15, -5 ,15, 18, 0 ,-5,  0, 11] :: Matrix 3 3 Double
b = [ 18, 22, 54, 42 , 22, 70, 86, 62 , 54, 86, 174, 134 , 42, 62, 134, 106] :: Matrix 4 4 Double
chol a
chol b
fmap (fixed (Just 3)) (a `mmult` recip a)
fmap (fixed (Just 3)) (b `mmult` recip b)
fmap (fixed (Just 3)) (dot sum (*) b (recip b))
#+end_src

#+RESULTS:
#+begin_example
[[5.0, 0.0, 0.0],
 [3.0, 3.0, 0.0],
 [-1.0, 1.0, 3.0]]
[[4.242640687119285, 0.0, 0.0, -5.102196573270443e-15],
 [5.185449728701349, 6.565905201197403, 0.0, 0.0],
 [12.727922061357857, 3.0460384954008553, 1.6497422479090704, 0.0],
 [9.899494936611667, 1.624553864213788, 1.8497110052313648, 1.3926212476456026]]
[["1.000", "0.000", "-0.000"],
 ["0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
#+end_example


* dyno development

#+begin_src haskell-ng :results output
import NumHask.Prelude
import NumHask.Array.Dynamic qualified as D

#+end_src

#+RESULTS:

#+begin_src haskell-ng :results output
let a = D.fromFlatList [2,3,4] [1..24] :: D.Array Int
a
#+end_src

#+RESULTS:
: [[[1, 2, 3, 4],
:   [5, 6, 7, 8],
:   [9, 10, 11, 12]],
:  [[13, 14, 15, 16],
:   [17, 18, 19, 20],
:   [21, 22, 23, 24]]]

** fixed

#+begin_src haskell-ng :results output
:set -XPolyKinds
:t Array @[2,3]

#+end_src

#+RESULTS:
: Array @[2,3] :: Data.Vector.Vector a -> Array [2, 3] a

#+begin_src haskell-ng :results output
fromList [1..24] :: Array [2,3,4] Int
#+end_src

#+RESULTS:
: [[[1, 2, 3, 4],
:   [5, 6, 7, 8],
:   [9, 10, 11, 12]],
:  [[13, 14, 15, 16],
:   [17, 18, 19, 20],
:   [21, 22, 23, 24]]]
