

* numhask-array

[[https://hackage.haskell.org/package/numhask-array][file:https://img.shields.io/hackage/v/numhask-array.svg]] [[https://github.com/tonyday567/numhask-array/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/numhask-array/workflows/haskell-ci/badge.svg]]

* Usage

This package provides an interface into the numhask API, and both type and value level shape manipulation routines.

#+begin_src haskell
:set -XRebindableSyntax
import NumHask.Prelude
import NumHask.Array
#+end_src

In situations where shape is only known at run-time, a clear module configuration is:

#+begin_src haskell
import NumHask.Array.Shape
import qualified NumHask.Array.Fixed as F
import qualified NumHask.Array.Dynamic as D
#+end_src

* recip development

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

#+begin_src haskell-ng :results output :exports both
>>>>>>> 50f9423 (shapeList and :|)
:r
:set -Wno-type-defaults
:set -Wno-unused-do-bind
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XOverloadedLabels
:set -XRebindableSyntax
:set -XDataKinds
import Data.Functor.Rep
import NumHask.Prelude
import NumHask.Array.Fixed qualified as F
import NumHask.Array.Shape qualified as S
import NumHask.Array.Dynamic qualified as D
putStrLn "ok"
#+end_src

** Cholesky decomposition

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

Example from https://rosettacode.org/wiki/Cholesky_decomposition#Haskell

#+begin_src haskell :results output :exports both
a = [25, 15, -5 ,15, 18, 0 ,-5,  0, 11] :: Matrix 3 3 Double
b = [ 18, 22, 54, 42 , 22, 70, 86, 62 , 54, 86, 174, 134 , 42, 62, 134, 106] :: Matrix 4 4 Double
chol a
chol b
fmap (fixed (Just 3)) (a `mmult` recip a)
fmap (fixed (Just 3)) (b `mmult` recip b)
fmap (fixed (Just 3)) (dot sum (*) b (recip b))
#+end_src

#+RESULTS:
#+begin_example
[[5.0, 0.0, 0.0],
 [3.0, 3.0, 0.0],
 [-1.0, 1.0, 3.0]]
[[4.242640687119285, 0.0, 0.0, -5.102196573270443e-15],
 [5.185449728701349, 6.565905201197403, 0.0, 0.0],
 [12.727922061357857, 3.0460384954008553, 1.6497422479090704, 0.0],
 [9.899494936611667, 1.624553864213788, 1.8497110052313648, 1.3926212476456026]]
[["1.000", "0.000", "-0.000"],
 ["0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
#+end_example

* dyno development

** imports

#+begin_src haskell-ng :results output
:r
:set -Wno-name-shadowing
:set -Wno-type-defaults
import NumHask.Prelude
import NumHask.Array.Dynamic as D
import NumHask.Array.Shape as S
import Prettyprinter
#+end_src

#+RESULTS:
#+begin_example
Build profile: -w ghc-9.8.2 -O1
In order, the following will be built (use -v for more details):
 - numhask-array-0.12 (lib) (file src/NumHask/Array/Dynamic.hs changed)
Preprocessing library for numhask-array-0.12..
GHCi, version 9.8.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/tonyday567/haskell/numhask-array/.ghci
[1 of 5] Compiling NumHask.Array.Shape ( src/NumHask/Array/Shape.hs, interpreted )
[2 of 5] Compiling NumHask.Array.Sort ( src/NumHask/Array/Sort.hs, interpreted )
[3 of 5] Compiling NumHask.Array.Dynamic ( src/NumHask/Array/Dynamic.hs, interpreted )
[4 of 5] Compiling NumHask.Array.Fixed ( src/NumHask/Array/Fixed.hs, interpreted )
[5 of 5] Compiling NumHask.Array    ( src/NumHask/Array.hs, interpreted )
Ok, five modules loaded.
Ok, five modules loaded.
#+end_example

#+begin_src haskell-ng :results output
a = iota [2,3,4] :: D.Array Int
pretty a
:t S.modifyIndex
-- :t \d o l a -> backpermute (S.replaceIndex d l) (S.modifyIndex d (+o)) a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]
: \d o l a -> backpermute (S.replaceIndex d l) (S.modifyIndex d (+o)) a
:   :: Int -> Int -> Int -> D.Array a -> D.Array a

** backpermute


| function      | f                                          | g                                                           |
|---------------+--------------------------------------------+-------------------------------------------------------------|
| takeD d t     | modifyIndex d . min t                      | id                                                          |
| dropD d t     | \s -> modifyIndex d (const ((s !! d) - t)) | (+t)                                                        |
| reshape s     | id                                         | shapen (shape a) .flatten                                   |
| rotates rs    | id                                         | S.rotateIndex rs                                            |
| diag          | minRank                                    | replicate (rank a) . head                                   |
| undiag        | replicate r . head                         | bool (const zero) id . S.isDiag                             |
| selectD d x   | S.deleteIndex d                            | S.addIndex d x                                              |
| extracts ds   | S.takeIndexes ds                           | S.addIndexes ds                                             |
| joins ds      | S.addIndexes ds (index a 0)                | index (index a (S.takeIndexes s ds)) (S.deleteIndexes s ds) |
| expand f      | (<>)                                       | (List.take (rank a), List.drop (rank a))                    |
| slice pss     | (S.ranks pss)                              | List.zipWith (!!) pss                                       |
| reorder ds    | S.reorder ds                               | S.addIndexes [] ds                                          |
| reverses ds   | id                                         | S.reverseIndex ds                                           |
| inflates ds n | S.addIndexes ds n                          | S.deleteIndexes ds                                          |
| transpose     | List.reverse                               | List.reverse                                                |
|               |                                            |                                                             |



#+begin_src haskell-ng :results output
import qualified Data.List as List
x = iota [2,3]
x
D.backpermute (List.drop 1 :: [Int] -> [Int]) x
#+end_src

#+RESULTS:
: UnsafeArray [2,3] [0,1,2,3,4,5]
: UnsafeArray [3] [0,0,0]

** iota

#+begin_src haskell-ng :results output
D.range (D.toScalar 3)
D.join $ D.tabulateA (D.toScalar 3) id
D.join $ D.tabulate (D.toScalar 3) id
D.tabulate (D.toScalar 3) id
D.tabulateA (D.toScalar 3) id
#+end_src

#+RESULTS:
: UnsafeArray [3] [0,1,2]
: UnsafeArray [3] [0,1,2]
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [3] [UnsafeArray [1] [0],UnsafeArray [1] [1],UnsafeArray [1] [2]]
: UnsafeArray [3] [UnsafeArray [] [0],UnsafeArray [] [1],UnsafeArray [] [2]]

** zipWith

#+begin_src haskell-ng :results output
m = D.array [3,4] [0..11]
m
D.zipWith (-) m m
D.zipWithE (-) m m
#+end_src

#+RESULTS:
: UnsafeArray [3,4] [0,1,2,3,4,5,6,7,8,9,10,11]
: UnsafeArray [3,4] [0,0,0,0,0,0,0,0,0,0,0,0]
: UnsafeArray [3,4] [0,0,0,0,0,0,0,0,0,0,0,0]

** cons

#+begin_src haskell-ng :results output
(x:|xs) = array [4] [0..3]
x
xs
(x:|xs)
#+end_src

#+RESULTS:
: UnsafeArray [] [0]
: UnsafeArray [3] [1,2,3]
: UnsafeArray [4] [0,1,2,3]


** transmit

Apply a binary fnuction to sub-components of an array matching the size of the second array, and an array.

#+begin_src haskell-ng :results output
import qualified Data.List as List
a = D.array [2,3] [0..5]
b = D.array [3] [0..2]
D.extracts [1] a
D.extracts [0] b
f = D.concatenate 0
D.transmits [(1,0)] f a b
#+end_src

#+RESULTS:
: UnsafeArray [3] [UnsafeArray [2] [0,3],UnsafeArray [2] [1,4],UnsafeArray [2] [2,5]]
: UnsafeArray [3] [UnsafeArray [] [0],UnsafeArray [] [1],UnsafeArray [] [2]]
: UnsafeArray [3,3] [0,3,0,1,4,1,2,5,2]

** 3-Dim example

#+begin_src haskell-ng :results output
let a = D.array [2,3,4] [0..23] :: D.Array Int
pretty a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

#+begin_src haskell-ng :results output
pretty $ (D.shape @[Int]) <$> D.extracts [0] a
#+end_src

#+RESULTS:
: [[3,4],[3,4]]

*** scalars

#+begin_src haskell-ng :results output
s = D.tabulate [] (const 0) :: D.Array Int
s
pretty s
s1 = D.array [1] [0]
s1
pretty s1
s2 = D.toScalar 0
s2
pretty s2
#+end_src

*** tabulate

#+begin_src haskell-ng :results output
s3 = tabulate [] (const 3) :: D.Array Int
s3
s3' = tabulate [1] (const 3) :: D.Array Int
s3'
s3'' = tabulate (Scalar 1) (const 3) :: D.Array Int
s3''
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [1], toVector = [3]}
: Array {toShape = [1], toVector = [3]}

*** indices

#+begin_src haskell-ng :results output
D.indices []
D.indices [3]
D.indices (Scalar 3)
D.indices (D.array [] [3])
D.indices [2,3]
#+end_src

#+RESULTS:
: UnsafeArray [] [[]]
: UnsafeArray [3] [[0],[1],[2]]
: UnsafeArray [] [Scalar 0,Scalar 1,Scalar 2]
: UnsafeArray [3] [UnsafeArray [1] [0],UnsafeArray [1] [1],UnsafeArray [1] [2]]
: UnsafeArray [2,3] [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]]

*** range

#+begin_src haskell-ng :results output
joins' $ fmap D.asArray $ D.indices []
joins' $ fmap D.asArray $ D.indices [3]
joins' $ fmap D.asArray $ D.indices (Scalar 3)
joins' $ fmap D.asArray $ D.indices (D.array [] [3])
joins' $ fmap D.asArray $ D.indices [2,3]
#+end_src

#+RESULTS:
: UnsafeArray [0] []
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [] [0]
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [2,3,2] [0,0,0,1,0,2,1,0,1,1,1,2]

*** diag

#+begin_src haskell-ng :results output
import NumHask.Array.Shape as S
:set -Wno-x-partial
a = D.array [] [3]
D.diag a
D.diag (D.array [3] [1,2,3])
D.diag (D.ident [3,2])
-- D.tabulate [S.minimum (zero:D.shape a)] (\xs -> index a (replicate (D.rank a) (head xs)))
-- D.tabulate [] (\xs -> index a (replicate (D.rank a) (head xs)))
-- S.minimum ((D.shape a) :: [Int])
-- index a []

#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [3], toVector = [1,2,3]}
: Array {toShape = [2], toVector = [1,1]}

** selects

#+begin_src haskell-ng :results output
D.selects [2] [1] (D.array [] [3::Int])
D.selects [0] [2] (D.array [3] [0..2::Int])
m = D.reshape [2,3] (D.range [6])
pretty m
D.selects [1] [0] (D.reshape [2,3] (D.range [6]))
D.selects [1] [2] (D.reshape [2,3] (D.range [6]))
D.selects [0,1] [1,2] (D.reshape [2,3] (D.range [6]))
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [], toVector = [2]}
: [[0,1,2],
:  [3,4,5]]
: Array {toShape = [2], toVector = [0,3]}
: Array {toShape = [2], toVector = [2,5]}
: Array {toShape = [], toVector = [5]}

#+begin_src haskell-ng :results output
:t D.index @[Int]
:t \a -> D.index @_ @[Int] a
:t D.index @_ @[Int]
#+end_src

#+RESULTS:
: D.index @[Int] :: FromVector [Int] Int => D.Array a -> [Int] -> a
: \a -> D.index @_ @[Int] a
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]
: D.index @_ @[Int]
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]

** folds



#+begin_src haskell-ng :results output
pretty $ D.folds [0,1] (sum . fmap (const one)) a
#+end_src

#+RESULTS:
#+begin_example
<interactive>:193:18: error: [GHC-83865]
    • Couldn't match expected type: D.Array Int -> b0
                  with actual type: [a1]
    • In the first argument of ‘D.folds’, namely ‘[0, 1]’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a

<interactive>:193:25: error: [GHC-83865]
    • Couldn't match type ‘(->) (f0 a0)’ with ‘[]’
      Expected: [Int]
        Actual: f0 a0 -> Int
    • Probable cause: ‘(.)’ is applied to too few arguments
      In the second argument of ‘D.folds’, namely
        ‘(sum . fmap (const one))’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a
#+end_example

** extracts

#+begin_src haskell-ng :results output
D.extracts [0,1] a
#+end_src

#+RESULTS:
: Array {toShape = [2,3], toVector = [Array {toShape = [4], toVector = [0,1,2,3]},Array {toShape = [4], toVector = [4,5,6,7]},Array {toShape = [4], toVector = [8,9,10,11]},Array {toShape = [4], toVector = [12,13,14,15]},Array {toShape = [4], toVector = [16,17,18,19]},Array {toShape = [4], toVector = [20,21,22,23]}]}

#+begin_src haskell-ng :results output
D.joins [0,1] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
D.joins [0,1] $ D.extracts [1,0] $ D.joins [1,0] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
pretty $ D.maps (D.reverses [0]) [0] a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

#+begin_src haskell-ng :results output
pretty $ D.insert 2 2 a (D.array [2,3] [100..105])
#+end_src

#+RESULTS:
: [[[0,1,100,2,3],
:   [4,5,101,6,7],
:   [8,9,102,10,11]],
:  [[12,13,103,14,15],
:   [16,17,104,18,19],
:   [20,21,105,22,23]]]

** dimension

#+begin_src haskell-ng :results output
S.dimension (D.shape a) 2
#+end_src

#+RESULTS:
: 4

** reverses

#+begin_src haskell-ng :results output
S.reverseIndex [0] [] []
S.reverseIndex [0] [5] [0]
S.reverseIndex [0] [5] [4]
S.reverseIndex [2] [2,3,4] [0,1,2]
#+end_src

#+RESULTS:
: []
: [4]
: [0]
: [0,1,1]

#+begin_src haskell-ng :results output
:t (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
#+end_src

#+RESULTS:
: (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
:   :: (Subtractive b, Foldable t, Eq a, Num b, Num a, Enum a) =>
:      t a -> [b] -> [b] -> [b]

#+begin_src haskell-ng :results output
pretty $ D.reverses [0] $ D.array [3,2] [1..6]
#+end_src

#+RESULTS:
: [[5,6],
:  [3,4],
:  [1,2]]

#+begin_src haskell-ng :results output
import Data.Proxy
import NumHask.Array.Fixed as F
:t with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.selects (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)

pretty $ with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.selects (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)
#+end_src

#+RESULTS:
: with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.selects (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)
:   :: F.Array '[4] Int
: [17,18,19,20]

** cons

#+begin_src haskell-ng :results output
let a = D.array [2,3,4] [0..23] :: D.Array Int
a
#+end_src

#+RESULTS:
: UnsafeArray [2,3,4] [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]

#+begin_src haskell-ng :results output
m = D.array [3,2] [0..5]
(x:|xs) = D.array [3,2] [0..5]
pretty x
pretty xs
#+end_src

#+RESULTS:
#+begin_example
[0,1]
[0,2,4]
<interactive>:402:1: error: [GHC-87543]
    Ambiguous occurrence ‘selects’.
    It could refer to
       either ‘F.selects’,
              imported from ‘NumHask.Array.Fixed’
              (and originally defined at src/NumHask/Array/Fixed.hs:486:1-7),
           or ‘D.selects’,
              imported from ‘NumHask.Array.Dynamic’
              (and originally defined at src/NumHask/Array/Dynamic.hs:489:1-7).
#+end_example

#+begin_src haskell-ng :results output
D.selects' [(0,0)] m
D.drops [1,0] m
#+end_src

#+RESULTS:
: UnsafeArray [2] [0,1]
: UnsafeArray [2,2] [2,3,4,5]
#+begin_src haskell-ng :results output
:t foldl'
#+end_src

#+RESULTS:
: foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

* scalar applications

#+begin_src haskell-ng :results output
S.shapenL [] 20
S.flattenL [] []
S.checkIndex 0 0
S.deleteIndex [] 2
S.replaceIndex 0 1 []
S.modifyIndex 0 (+1) []
S.replaceIndex 1 3 []
S.reverseIndex [0] [] []
S.rotateIndex [(0,1)] [] [1]
#+end_src

#+RESULTS:
: []
: 0
: True
: []
: []
: []
: []
: []
: [1]

#+begin_src haskell-ng :results output
D.stretch 0 (D.toScalar 1)
#+end_src

#+RESULTS:
: UnsafeArray [1] [1]

#+begin_src haskell-ng :results output
x = D.toScalar 1 :: D.Array Int
y = D.toScalar 2 :: D.Array Int
D.length x
fmap (+1) x
-- > toScalar x == D.tabulate [] (const x)
D.index x []
D.indices []
D.selects [] x
D.selects [(0,0)] x
D.selects [(2,2)] x
D.takes [] x
D.takes [(0,1)] x
D.takes [(1,1)] x

-- D.drops [(0,0)] x
-- D.row 0 (D.toScalar 2)
-- D.concatenate 0 (D.toScalar 2) (D.toScalar 3)
#+end_src

#+RESULTS:
#+begin_example
1
UnsafeArray [] [2]
1
UnsafeArray [] [[]]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [1] [1]
UnsafeArray [1] [1]
#+end_example

#+begin_src haskell-ng :results output
A.divide (D.toScalar 1) (D.toScalar 2)
#+end_src

#+RESULTS:
: Right (UnsafeArray [] [0.5])

* fixed

#+begin_src haskell-ng :results output
:set -XPolyKinds
:t Array @[2,3]

#+end_src

#+RESULTS:
: Array @[2,3] :: Data.Vector.Vector a -> Array [2, 3] a

#+begin_src haskell-ng :results output
fromList [1..24] :: Array [2,3,4] Int
#+end_src

#+RESULTS:
: [[[1, 2, 3, 4],
:   [5, 6, 7, 8],
:   [9, 10, 11, 12]],
:  [[13, 14, 15, 16],
:   [17, 18, 19, 20],
:   [21, 22, 23, 24]]]

* reference

[[https://link.springer.com/chapter/10.1007/978-3-662-54434-1_21][APLicative Programming with Naperian Functors]]
