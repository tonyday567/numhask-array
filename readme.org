

* numhask-array

[[https://hackage.haskell.org/package/numhask-array][file:https://img.shields.io/hackage/v/numhask-array.svg]] [[https://github.com/tonyday567/numhask-array/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/numhask-array/workflows/haskell-ci/badge.svg]]

* Usage

This package provides an interface into the numhask API, and both type and value level shape manipulation routines.

#+begin_src haskell
:set -XRebindableSyntax
import NumHask.Prelude
import NumHask.Array
#+end_src

In situations where shape is only known at run-time, a clear module configuration is:

#+begin_src haskell
import NumHask.Array.Shape
import qualified NumHask.Array.Fixed as F
import qualified NumHask.Array.Dynamic as D
#+end_src

* recip development

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

#+begin_src haskell-ng :results output :exports both
>>>>>>> 50f9423 (shapeList and :|)
:r
:set -Wno-type-defaults
:set -Wno-unused-do-bind
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XOverloadedLabels
:set -XRebindableSyntax
:set -XDataKinds
import Data.Functor.Rep
import NumHask.Prelude
import NumHask.Array.Fixed qualified as F
import NumHask.Array.Shape qualified as S
import NumHask.Array.Dynamic qualified as D
putStrLn "ok"
#+end_src

** Cholesky decomposition

'chol' uses the [[https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm][Cholesky-Crout]] algorithm.

Example from https://rosettacode.org/wiki/Cholesky_decomposition#Haskell

#+begin_src haskell :results output :exports both
a = [25, 15, -5 ,15, 18, 0 ,-5,  0, 11] :: Matrix 3 3 Double
b = [ 18, 22, 54, 42 , 22, 70, 86, 62 , 54, 86, 174, 134 , 42, 62, 134, 106] :: Matrix 4 4 Double
chol a
chol b
fmap (fixed (Just 3)) (a `mmult` recip a)
fmap (fixed (Just 3)) (b `mmult` recip b)
fmap (fixed (Just 3)) (dot sum (*) b (recip b))
#+end_src

#+RESULTS:
#+begin_example
[[5.0, 0.0, 0.0],
 [3.0, 3.0, 0.0],
 [-1.0, 1.0, 3.0]]
[[4.242640687119285, 0.0, 0.0, -5.102196573270443e-15],
 [5.185449728701349, 6.565905201197403, 0.0, 0.0],
 [12.727922061357857, 3.0460384954008553, 1.6497422479090704, 0.0],
 [9.899494936611667, 1.624553864213788, 1.8497110052313648, 1.3926212476456026]]
[["1.000", "0.000", "-0.000"],
 ["0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
[["1.000", "0.000", "-0.000", "0.000"],
 ["-0.000", "1.000", "-0.000", "0.000"],
 ["-0.000", "0.000", "1.000", "0.000"],
 ["-0.000", "0.000", "-0.000", "1.000"]]
#+end_example

* dyno development

** imports

#+begin_src haskell-ng :results output
:r
:set -Wno-name-shadowing
:set -Wno-type-defaults
import NumHask.Prelude
import NumHask.Array.Dynamic as D
import NumHask.Array.Shape as S
import Prettyprinter
import System.Random
import System.Random.Stateful
#+end_src

#+RESULTS:
: [3 of 5] Compiling NumHask.Array.Dynamic ( src/NumHask/Array/Dynamic.hs, interpreted ) [Source file changed]
: Ok, five modules loaded.

#+begin_src haskell-ng :results output
a = fmap (1+) $ range [2,3,4] :: D.Array Int
pretty a
-- :t \d o l a -> backpermute (S.replaceDim d l) (S.modifyDim d (+o)) a
#+end_src

#+RESULTS:
: [[[1,2,3,4],
:   [5,6,7,8],
:   [9,10,11,12]],
:  [[13,14,15,16],
:   [17,18,19,20],
:   [21,22,23,24]]]

#+begin_src haskell-ng :results output
a = D.array [3,3] [4,12,-16,12,37,-43,-16,-43,98] :: D.Array Double
pretty (D.chol a)
D.mult (D.chol a) (D.transpose (D.chol a)) == a
pretty (D.inverse a)
D.mult (D.inverse a) a == a
#+end_src

#+RESULTS:
: [[2.0,0.0,0.0],
:  [6.0,1.0,0.0],
:  [-8.0,5.0,3.0]]
: True
: [[49.36111111111111,-13.555555555555554,2.1111111111111107],
:  [-13.555555555555554,3.7777777777777772,-0.5555555555555555],
:  [2.1111111111111107,-0.5555555555555555,0.1111111111111111]]
: False

#+begin_src haskell-ng :results output
a = D.array [3,3] ([1,0,1,0,1,2,0,0,1] :: [Double]) :: D.Array Double
n = D.shape a !! 0
ti = D.undiag 2 (fmap recip (D.diag a))
tl = zipWithE (-) a (D.undiag 2 (D.diag a))
l = fmap negate (D.dot sum (*) ti tl)
l
-- fmap (sum (fmap (l ^) (fmap fromIntegral $ D.range [n])) *) ti

seq = D.range [n] :: D.Array Int
x' = fmap (\x -> fmap (^x) l) seq
D.shape x'
D.shape (x' ! [0,0])


foldr (zipWithE (+)) (x' ! [0]) (D.tails [0] x')
D.isScalar $ heads [0] x'
x' ! [0]
D.tails [0] x'
#+end_src

#+RESULTS:
: UnsafeArray [3,3] [-0.0,-0.0,-1.0,-0.0,-0.0,-2.0,-0.0,-0.0,-0.0]
: [3]
: [3,3]
: UnsafeArray [3,3] [1.0,1.0,1.0,1.0,1.0,3.0,1.0,1.0,1.0]
: True
: UnsafeArray [3,3] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
: UnsafeArray [2] [UnsafeArray [3,3] [-0.0,-0.0,-1.0,-0.0,-0.0,-2.0,-0.0,-0.0,-0.0],UnsafeArray [3,3] [0.0,0.0,1.0,0.0,0.0,4.0,0.0,0.0,0.0]]

#+begin_src haskell-ng :results output
import NumHask.Array.Fixed as F
import Data.Functor.Rep
:set -XOverloadedLists
a' = [1,0,1,0,1,2,0,0,1] :: F.Array '[3,3] Double
n = F.shape a' !! 0
ti = F.undiag (fmap recip (F.diag a'))
tl = a' - (F.undiag (F.diag a'))
l = fmap negate (F.dot sum (*) ti tl)
invtri a'
#+end_src

#+RESULTS:
: [1.0,0.0,-1.0,0.0,1.0,-2.0,0.0,0.0,1.0]


#+begin_src haskell-ng :results output
:t l
(l ^ 1)
(l ^^ 2)
#+end_src

#+RESULTS:
: l :: F.Array [3, 3] Double
: [-0.0,-0.0,-1.0,-0.0,-0.0,-2.0,-0.0,-0.0,-0.0]
: [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]

#+begin_src haskell-ng :results output
a = D.array [3,3] ([1,0,1,0,1,2,0,0,1] :: [Double]) :: D.Array Double
n = D.shape a !! 0
ti = D.undiag 2 (fmap recip (D.diag a))
tl = zipWithE (-) a (D.undiag 2 (D.diag a))
l = fmap negate (D.dot sum (*) ti tl)
pow a n = foldr ($) (D.ident [3,3]) (replicate n (D.mult a))
:t pow
pow l 2
add = zipWithE (+)
sum' = foldl' add (D.konst [3,3] 0)
:t sum'
D.mult (sum' (fmap (pow l) (fmap fromIntegral $ D.range [n]))) ti
#+end_src

#+RESULTS:
: pow
:   :: (Additive a, Multiplicative a) => D.Array a -> Int -> D.Array a
: UnsafeArray [3,3] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
: sum'
:   :: (Foldable t, Additive c, Num c) => t (D.Array c) -> D.Array c
: UnsafeArray [3,3] [1.0,0.0,-1.0,0.0,1.0,-2.0,0.0,0.0,1.0]

#+begin_src haskell-ng :results output
import Control.Monad
xs n = replicateM n . uniformRM (0,1)
:t xs
gen <- newIOGenM (mkStdGen 42)
:t xs 10 gen :: IO [Double]
#+end_src

#+RESULTS:
: xs
:   :: (UniformRange a1, StatefulGen a2 m, Num a1) =>
:      Int -> a2 -> m [a1]
: xs 10 gen :: IO [Double] :: IO [Double]


** backpermute

#+begin_src haskell-ng :results output
import qualified Data.List as List
x = range [2,3]
x
D.backpermute (List.drop 1 :: [Int] -> [Int]) x
#+end_src

#+RESULTS:
: UnsafeArray [2,3] [0,1,2,3,4,5]
: UnsafeArray [3] [0,0,0]

** range

#+begin_src haskell-ng :results output
D.range (D.toScalar 3)
D.join $ D.tabulateA (D.toScalar 3) id
D.join $ D.tabulate (D.toScalar 3) id
D.tabulate (D.toScalar 3) id
D.tabulateA (D.toScalar 3) id
#+end_src

#+RESULTS:
: UnsafeArray [3] [0,1,2]
: UnsafeArray [3] [0,1,2]
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [3] [UnsafeArray [1] [0],UnsafeArray [1] [1],UnsafeArray [1] [2]]
: UnsafeArray [3] [UnsafeArray [] [0],UnsafeArray [] [1],UnsafeArray [] [2]]

** zipWith

#+begin_src haskell-ng :results output
m = D.array [3,4] [0..11]
m
D.zipWith (-) m m
D.zipWithE (-) m m
#+end_src

#+RESULTS:
: UnsafeArray [3,4] [0,1,2,3,4,5,6,7,8,9,10,11]
: UnsafeArray [3,4] [0,0,0,0,0,0,0,0,0,0,0,0]
: UnsafeArray [3,4] [0,0,0,0,0,0,0,0,0,0,0,0]

** cons

#+begin_src haskell-ng :results output
(x:|xs) = array [4] [0..3]
x
xs
(x:|xs)
#+end_src

#+RESULTS:
: UnsafeArray [] [0]
: UnsafeArray [3] [1,2,3]
: UnsafeArray [4] [0,1,2,3]


** transmit

Apply a binary fnuction to sub-components of an array matching the size of the second array, and an array.

#+begin_src haskell-ng :results output
import qualified Data.List as List
a = D.array [2,3] [0..5]
b = D.array [3] [0..2]
D.extracts [1] a
D.extracts [0] b
f = D.concatenate 0
D.transmits [(1,0)] f a b
#+end_src

#+RESULTS:
: UnsafeArray [3] [UnsafeArray [2] [0,3],UnsafeArray [2] [1,4],UnsafeArray [2] [2,5]]
: UnsafeArray [3] [UnsafeArray [] [0],UnsafeArray [] [1],UnsafeArray [] [2]]
: UnsafeArray [3,3] [0,3,0,1,4,1,2,5,2]

** 3-Dim example

#+begin_src haskell-ng :results output
let a = D.array [2,3,4] [0..23] :: D.Array Int
pretty a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

#+begin_src haskell-ng :results output
pretty $ (D.shape @[Int]) <$> D.extracts [0] a
#+end_src

#+RESULTS:
: [[3,4],[3,4]]

*** scalars

#+begin_src haskell-ng :results output
s = D.tabulate [] (const 0) :: D.Array Int
s
pretty s
s1 = D.array [1] [0]
s1
pretty s1
s2 = D.toScalar 0
s2
pretty s2
#+end_src

*** tabulate

#+begin_src haskell-ng :results output
s3 = tabulate [] (const 3) :: D.Array Int
s3
s3' = tabulate [1] (const 3) :: D.Array Int
s3'
s3'' = tabulate (Scalar 1) (const 3) :: D.Array Int
s3''
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [1], toVector = [3]}
: Array {toShape = [1], toVector = [3]}

*** indices

#+begin_src haskell-ng :results output
D.indices []
D.indices [3]
D.indices (Scalar 3)
D.indices (D.array [] [3])
D.indices [2,3]
#+end_src

#+RESULTS:
: UnsafeArray [] [[]]
: UnsafeArray [3] [[0],[1],[2]]
: UnsafeArray [] [Scalar 0,Scalar 1,Scalar 2]
: UnsafeArray [3] [UnsafeArray [1] [0],UnsafeArray [1] [1],UnsafeArray [1] [2]]
: UnsafeArray [2,3] [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]]

*** range

#+begin_src haskell-ng :results output
joins' $ fmap D.asArray $ D.indices []
joins' $ fmap D.asArray $ D.indices [3]
joins' $ fmap D.asArray $ D.indices (Scalar 3)
joins' $ fmap D.asArray $ D.indices (D.array [] [3])
joins' $ fmap D.asArray $ D.indices [2,3]
#+end_src

#+RESULTS:
: UnsafeArray [0] []
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [] [0]
: UnsafeArray [3,1] [0,1,2]
: UnsafeArray [2,3,2] [0,0,0,1,0,2,1,0,1,1,1,2]

*** diag

#+begin_src haskell-ng :results output
import NumHask.Array.Shape as S
:set -Wno-x-partial
a = D.array [] [3]
D.diag a
D.diag (D.array [3] [1,2,3])
D.diag (D.ident [3,2])
-- D.tabulate [S.minimum (zero:D.shape a)] (\xs -> index a (replicate (D.rank a) (head xs)))
-- D.tabulate [] (\xs -> index a (replicate (D.rank a) (head xs)))
-- S.minimum ((D.shape a) :: [Int])
-- index a []

#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [3], toVector = [1,2,3]}
: Array {toShape = [2], toVector = [1,1]}

** indexes

#+begin_src haskell-ng :results output
D.indexes [2] [1] (D.array [] [3::Int])
D.indexes [0] [2] (D.array [3] [0..2::Int])
m = D.reshape [2,3] (D.range [6])
pretty m
D.indexes [1] [0] (D.reshape [2,3] (D.range [6]))
D.indexes [1] [2] (D.reshape [2,3] (D.range [6]))
D.indexes [0,1] [1,2] (D.reshape [2,3] (D.range [6]))
#+end_src

#+RESULTS:
: Array {toShape = [], toVector = [3]}
: Array {toShape = [], toVector = [2]}
: [[0,1,2],
:  [3,4,5]]
: Array {toShape = [2], toVector = [0,3]}
: Array {toShape = [2], toVector = [2,5]}
: Array {toShape = [], toVector = [5]}

#+begin_src haskell-ng :results output
:t D.index @[Int]
:t \a -> D.index @_ @[Int] a
:t D.index @_ @[Int]
#+end_src

#+RESULTS:
: D.index @[Int] :: FromVector [Int] Int => D.Array a -> [Int] -> a
: \a -> D.index @_ @[Int] a
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]
: D.index @_ @[Int]
:   :: FromVector w Int => D.Array [Int] -> w -> [Int]

** folds



#+begin_src haskell-ng :results output
pretty $ D.folds [0,1] (sum . fmap (const one)) a
#+end_src

#+RESULTS:
#+begin_example
<interactive>:193:18: error: [GHC-83865]
    • Couldn't match expected type: D.Array Int -> b0
                  with actual type: [a1]
    • In the first argument of ‘D.folds’, namely ‘[0, 1]’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a

<interactive>:193:25: error: [GHC-83865]
    • Couldn't match type ‘(->) (f0 a0)’ with ‘[]’
      Expected: [Int]
        Actual: f0 a0 -> Int
    • Probable cause: ‘(.)’ is applied to too few arguments
      In the second argument of ‘D.folds’, namely
        ‘(sum . fmap (const one))’
      In the second argument of ‘($)’, namely
        ‘D.folds [0, 1] (sum . fmap (const one)) a’
      In the expression:
        pretty $ D.folds [0, 1] (sum . fmap (const one)) a
#+end_example

** extracts

#+begin_src haskell-ng :results output
D.extracts [0,1] a
#+end_src

#+RESULTS:
: Array {toShape = [2,3], toVector = [Array {toShape = [4], toVector = [0,1,2,3]},Array {toShape = [4], toVector = [4,5,6,7]},Array {toShape = [4], toVector = [8,9,10,11]},Array {toShape = [4], toVector = [12,13,14,15]},Array {toShape = [4], toVector = [16,17,18,19]},Array {toShape = [4], toVector = [20,21,22,23]}]}

#+begin_src haskell-ng :results output
D.joins [0,1] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
D.joins [0,1] $ D.extracts [1,0] $ D.joins [1,0] (D.extracts [0,1] a)
#+end_src

#+RESULTS:
: Array {toShape = [2,3,4], toVector = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}

#+begin_src haskell-ng :results output
pretty $ D.maps (D.reverses [0]) [0] a
#+end_src

#+RESULTS:
: [[[0,1,2,3],
:   [4,5,6,7],
:   [8,9,10,11]],
:  [[12,13,14,15],
:   [16,17,18,19],
:   [20,21,22,23]]]

#+begin_src haskell-ng :results output
pretty $ D.insert 2 2 a (D.array [2,3] [100..105])
#+end_src

#+RESULTS:
: [[[0,1,100,2,3],
:   [4,5,101,6,7],
:   [8,9,102,10,11]],
:  [[12,13,103,14,15],
:   [16,17,104,18,19],
:   [20,21,105,22,23]]]

** dimension

#+begin_src haskell-ng :results output
S.index (D.shape a) 2
#+end_src

#+RESULTS:
: 4

** reverses

#+begin_src haskell-ng :results output
S.reverseIndex [0] [] []
S.reverseIndex [0] [5] [0]
S.reverseIndex [0] [5] [4]
S.reverseIndex [2] [2,3,4] [0,1,2]
#+end_src

#+RESULTS:
: []
: [4]
: [0]
: [0,1,1]

#+begin_src haskell-ng :results output
:t (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
#+end_src

#+RESULTS:
: (\ds ns xs -> fmap (\(i,x,n) -> bool x (n-1-x) (i `elem` ds)) (zip3 [0..] xs ns))
:   :: (Subtractive b, Foldable t, Eq a, Num b, Num a, Enum a) =>
:      t a -> [b] -> [b] -> [b]

#+begin_src haskell-ng :results output
pretty $ D.reverses [0] $ D.array [3,2] [1..6]
#+end_src

#+RESULTS:
: [[5,6],
:  [3,4],
:  [1,2]]

#+begin_src haskell-ng :results output
import Data.Proxy
import NumHask.Array.Fixed as F
:t with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.indexes (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)

pretty $ with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.indexes (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)
#+end_src

#+RESULTS:
: with (D.array @[Int] [2,3,4] [1..24]) (NumHask.Array.Fixed.indexes (Proxy :: Proxy '[0,1]) [1,1] :: F.Array '[2,3,4] Int -> F.Array '[4] Int)
:   :: F.Array '[4] Int
: [17,18,19,20]

** cons

#+begin_src haskell-ng :results output
let a = D.array [2,3,4] [0..23] :: D.Array Int
a
#+end_src

#+RESULTS:
: UnsafeArray [2,3,4] [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]

#+begin_src haskell-ng :results output
m = D.array [3,2] [0..5]
(x:|xs) = D.array [3,2] [0..5]
pretty x
pretty xs
#+end_src

#+RESULTS:
#+begin_example
[0,1]
[0,2,4]
<interactive>:402:1: error: [GHC-87543]
    Ambiguous occurrence ‘indexes’.
    It could refer to
       either ‘F.indexes’,
              imported from ‘NumHask.Array.Fixed’
              (and originally defined at src/NumHask/Array/Fixed.hs:486:1-7),
           or ‘D.indexes’,
              imported from ‘NumHask.Array.Dynamic’
              (and originally defined at src/NumHask/Array/Dynamic.hs:489:1-7).
#+end_example

#+begin_src haskell-ng :results output
D.indexes' [(0,0)] m
D.drops [1,0] m
#+end_src

#+RESULTS:
: UnsafeArray [2] [0,1]
: UnsafeArray [2,2] [2,3,4,5]
#+begin_src haskell-ng :results output
:t foldl'
#+end_src

#+RESULTS:
: foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

* scalar applications

#+begin_src haskell-ng :results output
S.shapen [] 20
S.flatten [] []
S.deleteDim [] 2
S.replaceDim 0 1 []
S.modifyDim 0 (+1) []
S.replaceDim 1 3 []
S.reverseIndex [0] [] []
S.rotateIndex [(0,1)] [] [1]
#+end_src

#+RESULTS:
: []
: 0
: True
: []
: []
: []
: []
: []
: [1]

#+begin_src haskell-ng :results output
D.stretch 0 (D.toScalar 1)
#+end_src

#+RESULTS:
: UnsafeArray [1] [1]

#+begin_src haskell-ng :results output
x = D.toScalar 1 :: D.Array Int
y = D.toScalar 2 :: D.Array Int
D.length x
fmap (+1) x
-- > toScalar x == D.tabulate [] (const x)
D.index x []
D.indices []
D.indexes [] x
D.indexes [(0,0)] x
D.indexes [(2,2)] x
D.takes [] x
D.takes [(0,1)] x
D.takes [(1,1)] x

-- D.drops [(0,0)] x
-- D.row 0 (D.toScalar 2)
-- D.concatenate 0 (D.toScalar 2) (D.toScalar 3)
#+end_src

#+RESULTS:
#+begin_example
1
UnsafeArray [] [2]
1
UnsafeArray [] [[]]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [] [1]
UnsafeArray [1] [1]
UnsafeArray [1] [1]
#+end_example

#+begin_src haskell-ng :results output
A.divide (D.toScalar 1) (D.toScalar 2)
#+end_src

#+RESULTS:
: Right (UnsafeArray [] [0.5])

* fixed

#+begin_src haskell-ng :results output
:set -XPolyKinds
:t Array @[2,3]

#+end_src

#+RESULTS:
: Array @[2,3] :: Data.Vector.Vector a -> Array [2, 3] a

#+begin_src haskell-ng :results output
fromList [1..24] :: Array [2,3,4] Int
#+end_src

#+RESULTS:
: [[[1, 2, 3, 4],
:   [5, 6, 7, 8],
:   [9, 10, 11, 12]],
:  [[13, 14, 15, 16],
:   [17, 18, 19, 20],
:   [21, 22, 23, 24]]]

* reference

[[https://link.springer.com/chapter/10.1007/978-3-662-54434-1_21][APLicative Programming with Naperian Functors]]
